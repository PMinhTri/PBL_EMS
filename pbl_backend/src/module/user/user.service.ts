import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreateUserDto, userInformationDto } from './user.dto';
import {
  ServiceFailure,
  ServiceResponse,
  ServiceResponseStatus,
} from 'src/serviceResponse';
import { UserFailure } from 'src/enumTypes/failure.enum';
import { MailService } from 'src/mail/mail.service';
import { autoGeneratedPassword, hashPassword } from 'src/utils/password';
import { FilterQuery, UserInformation } from './user.type';
import { Prisma, User } from '@prisma/client';
import { JobInformationService } from '../jobInformation/jobInformation.service';

@Injectable()
export class UserService {
  constructor(
    private prisma: PrismaService,
    private mailService: MailService,
    private jobInformationService: JobInformationService,
  ) {}

  public async createUser(
    dto: CreateUserDto,
  ): Promise<
    ServiceResponse<
      { user: CreateUserDto; password: string },
      ServiceFailure<UserFailure>
    >
  > {
    const existingUser = await this.prisma.user.findUnique({
      where: {
        email: dto.email,
      },
    });

    if (existingUser) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: UserFailure.USER_ALREADY_EXISTS,
        },
      };
    }
    const generatedPassword = autoGeneratedPassword();
    const hashedPassword = await hashPassword(generatedPassword);
    const user = await this.prisma.user.create({
      data: {
        email: dto.email,
        fullName: dto.fullName,
        password: hashedPassword,
        gender: dto.gender,
        status: dto.status,
        role: {
          connect: {
            id: dto.roleId,
          },
        },
      },

      select: {
        id: true,
        email: true,
        fullName: true,
        gender: true,
        status: true,
        roleId: true,
      },
    });

    try {
      await this.mailService.receiveDefaultPassword(
        dto.email,
        generatedPassword,
      );
    } catch (err) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: err,
        },
      };
    }

    return {
      status: ServiceResponseStatus.Success,
      result: { user, password: generatedPassword },
    };
  }

  public async importUsers(
    dto: CreateUserDto[],
  ): Promise<ServiceResponse<CreateUserDto[], ServiceFailure<UserFailure>>> {
    for (const user of dto) {
      const existingUser = await this.prisma.user.findUnique({
        where: {
          email: user.email,
        },
      });

      if (existingUser) {
        return {
          status: ServiceResponseStatus.Failed,
          failure: {
            reason: UserFailure.USER_ALREADY_EXISTS,
          },
        };
      }

      user.roleId = (
        await this.prisma.role.findFirst({
          where: {
            name: user.roleId,
          },
          select: {
            id: true,
          },
        })
      ).id;

      const generatedPassword = autoGeneratedPassword();
      const hashedPassword = await hashPassword(generatedPassword);

      await this.prisma.$transaction(async () => {
        const newUser = await this.prisma.user.create({
          data: {
            email: user.email,
            fullName: user.fullName,
            password: hashedPassword,
            status: user.status,
            gender: user.gender,
            role: {
              connect: {
                id: user.roleId,
              },
            },
          },
        });

        await this.jobInformationService.createJobInformation({
          userId: newUser.id,
          joinDate: new Date(),
          employeeStatus: user.status,
        });
      });

      try {
        await this.mailService.receiveDefaultPassword(
          user.email,
          generatedPassword,
        );
      } catch (err) {
        return {
          status: ServiceResponseStatus.Failed,
          failure: {
            reason: err,
          },
        };
      }
    }

    return {
      status: ServiceResponseStatus.Success,
    };
  }

  public async getAllEmails(): Promise<string[]> {
    const emails = await this.prisma.user.findMany({
      select: {
        email: true,
      },
    });

    return emails.map((email) => email.email);
  }

  public async updatePersonalInformation(
    id: string,
    dto: Partial<userInformationDto>,
  ): Promise<ServiceResponse<User, ServiceFailure<UserFailure>>> {
    const user = await this.prisma.user.findUnique({
      where: {
        id: id,
      },
    });

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: UserFailure.USER_NOT_FOUND,
        },
      };
    }

    await this.prisma.user.update({
      where: {
        id: user.id,
      },
      data: {
        fullName: dto.fullName,
        gender: dto.gender,
        dateOfBirth: new Date(dto.dateOfBirth),
        phoneNumber: dto.phoneNumber,
        citizenId: dto.citizenId,
        address: dto.address,
        city: dto.city,
        nationality: dto.nationality,
        educationId: dto.educationId,
      },
    });

    return {
      status: ServiceResponseStatus.Success,
    };
  }

  public async updateAvatar(id: string, avatar: string) {
    const user = await this.prisma.user.findUnique({
      where: {
        id: id,
      },
    });

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: UserFailure.USER_NOT_FOUND,
        },
      };
    }

    await this.prisma.user.update({
      where: {
        id: id,
      },
      data: {
        avatar: avatar,
      },
    });

    return {
      status: ServiceResponseStatus.Success,
    };
  }

  public async deleteAvatar(id: string) {
    const user = await this.prisma.user.findUnique({
      where: {
        id: id,
      },
    });

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: UserFailure.USER_NOT_FOUND,
        },
      };
    }

    await this.prisma.user.update({
      where: {
        id: id,
      },
      data: {
        avatar: null,
      },
    });

    return {
      status: ServiceResponseStatus.Success,
    };
  }

  public async getAllUsers(
    searchQuery?: string,
    filterQuery?: FilterQuery,
  ): Promise<
    ServiceResponse<userInformationDto[], ServiceFailure<UserFailure>>
  > {
    const where = {} as Prisma.UserWhereInput;

    if (searchQuery) {
      where.OR = [
        { fullName: { contains: searchQuery } },
        { email: { contains: searchQuery } },
        { phoneNumber: { contains: searchQuery } },
        { citizenId: { contains: searchQuery } },
      ];
    }

    where.jobInformation = {
      ...(filterQuery.jobTitleId && { jobTitleId: filterQuery.jobTitleId }),
      ...(filterQuery.departmentId && {
        departmentId: filterQuery.departmentId,
      }),
      ...(filterQuery.employeeStatus && {
        employeeStatusId: filterQuery.employeeStatus,
      }),
      ...(filterQuery.contractId && {
        contractTypeId: filterQuery.contractId,
      }),
    };

    if (filterQuery.gender) {
      where.gender = filterQuery.gender;
    }

    if (filterQuery.educationId) {
      where.educationId = filterQuery.educationId;
    }

    const userInformation = await this.prisma.user.findMany({
      where,
      select: {
        id: true,
        email: true,
        fullName: true,
        gender: true,
        dateOfBirth: true,
        phoneNumber: true,
        citizenId: true,
        address: true,
        city: true,
        nationality: true,
        avatar: true,
        status: true,
        role: {
          select: {
            name: true,
          },
        },
        education: {
          select: {
            grade: true,
          },
        },
        jobInformation: {
          select: {
            id: true,
            joinDate: true,
            employeeStatus: true,
            contractId: true,
            contractType: {
              select: {
                type: true,
              },
            },
            contractStartDate: true,
            contractEndDate: true,
            jobTitleId: true,
            jobTitle: {
              select: {
                name: true,
              },
            },
            departmentId: true,
            department: {
              select: {
                name: true,
              },
            },
            workingSkill: {
              select: {
                id: true,
                name: true,
                description: true,
              },
            },
          },
        },
      },
    });

    return {
      status: ServiceResponseStatus.Success,
      result: userInformation,
    };
  }

  public async getById(
    id: string,
  ): Promise<ServiceResponse<UserInformation, ServiceFailure<UserFailure>>> {
    const user = await this.prisma.user.findUnique({
      where: {
        id: id,
      },
      select: {
        id: true,
        email: true,
        fullName: true,
        gender: true,
        dateOfBirth: true,
        phoneNumber: true,
        address: true,
        citizenId: true,
        city: true,
        nationality: true,
        avatar: true,
        status: true,
        role: {
          select: {
            name: true,
          },
        },
        education: {
          select: {
            grade: true,
          },
        },
        jobInformation: {
          select: {
            joinDate: true,
            employeeStatus: true,
            contractType: {
              select: {
                type: true,
              },
            },
            contractStartDate: true,
            contractEndDate: true,
            jobTitle: {
              select: {
                name: true,
              },
            },
            department: {
              select: {
                name: true,
              },
            },
            workingSkill: {
              select: {
                name: true,
                description: true,
              },
            },
          },
        },
      },
    });

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: UserFailure.USER_NOT_FOUND,
        },
      };
    }

    return {
      status: ServiceResponseStatus.Success,
      result: user,
    };
  }

  public async deleteById(
    id: string,
  ): Promise<ServiceResponse<User, ServiceFailure<UserFailure>>> {
    const user = await this.prisma.user.findUnique({
      where: {
        id: id,
      },
      include: {
        jobInformation: true,
      },
    });

    if (!user) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: UserFailure.USER_NOT_FOUND,
        },
      };
    }

    await this.prisma.$transaction(async () => {
      await this.prisma.jobInformation.findFirst({
        where: {
          userId: id,
        },
      });

      await this.prisma.timeSheet.deleteMany({
        where: {
          userId: id,
        },
      });

      await this.prisma.leaveRequest.deleteMany({
        where: {
          userId: id,
        },
      });

      await this.prisma.payroll.deleteMany({
        where: {
          userId: id,
        },
      });
    });

    await this.prisma.user.delete({
      where: {
        id: id,
      },
    });

    return {
      status: ServiceResponseStatus.Success,
      result: user,
    };
  }
}
