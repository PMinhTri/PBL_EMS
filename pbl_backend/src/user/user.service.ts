import { Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { createUserDto } from './dto/user.dto';
import {
  ServiceFailure,
  ServiceResponse,
  ServiceResponseStatus,
} from 'src/serviceResponse';
import * as argon from 'argon2';
import { randomBytes } from 'crypto';
import { CreateUserFailure } from 'src/enumTypes/enumFailures/user.failure.enum';
import { MailService } from 'src/mail/mail.service';

@Injectable()
export class UserService {
  constructor(
    private prisma: PrismaService,
    private mailService: MailService,
  ) {}

  async createUser(
    dto: createUserDto,
  ): Promise<
    ServiceResponse<
      { user: createUserDto; password: string },
      ServiceFailure<CreateUserFailure>
    >
  > {
    const existingUser = await this.prisma.user.findUnique({
      where: {
        email: dto.email,
      },
    });

    if (existingUser) {
      return {
        status: ServiceResponseStatus.Failed,
        failure: {
          reason: CreateUserFailure.USER_ALREADY_EXISTS,
        },
      };
    }

    const autoGeneratedPassword = Math.random().toString(36).slice(-8);
    const generateSalt = randomBytes(16);
    const hashedPassword = await argon.hash(autoGeneratedPassword, {
      salt: generateSalt,
      saltLength: 16,
    });

    await this.mailService.receiveDefaultPassword(
      dto.email,
      autoGeneratedPassword,
    );

    const user = await this.prisma.user.create({
      data: {
        email: dto.email,
        fullName: dto.fullName,
        password: hashedPassword,
        gender: dto.gender,
        status: dto.status,
        roleId: dto.roleId,
      },

      select: {
        id: true,
        email: true,
        fullName: true,
        password: true,
        gender: true,
        status: true,
        roleId: true,
      },
    });

    return {
      status: ServiceResponseStatus.Success,
      result: { user, password: autoGeneratedPassword },
    };
  }
}
